<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>React Character Counter</title>
    <style>
      :root {
        --card-bg: rgba(255, 255, 255, 0.95);
        --page-gradient: linear-gradient(160deg, #fdfdff 0%, #eff1fb 40%, #ebeefa 70%, #f6f2ff 100%);
        --accent: #b59cff;
        --accent-strong: #8c73f5;
        --accent-pop: #ffb7f5;
        --danger: #d45874;
        --text: #1c1f33;
        --muted: #5b6277;
        --border: #dce0ef;
        --shadow: 0 35px 70px rgba(30, 33, 50, 0.2);
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        font-family: "SF Pro Display", "Inter", "Segoe UI", -apple-system, BlinkMacSystemFont, sans-serif;
        background: #f3f4fb;
        color: var(--text);
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 24px;
        position: relative;
        overflow: hidden;
      }

      body::before {
        content: "";
        position: absolute;
        inset: -10%;
        background: var(--page-gradient);
        filter: blur(25px);
        z-index: 0;
      }

      body::after {
        content: "";
        position: absolute;
        width: 320px;
        height: 320px;
        top: 10%;
        right: 12%;
        background: radial-gradient(circle, rgba(181, 156, 255, 0.45) 0%, rgba(232, 206, 255, 0) 70%);
        filter: blur(5px);
        z-index: 0;
        animation: float 10s ease-in-out infinite alternate;
      }

      #root {
        width: min(640px, 100%);
        position: relative;
        z-index: 1;
      }

      h1 {
        margin: 0 0 24px;
        font-size: clamp(1.8rem, 4vw, 2.4rem);
        text-align: center;
        letter-spacing: -0.02em;
        background: linear-gradient(120deg, #1c1f33, #5e5f7c 40%, var(--accent-strong));
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
      }

      .card {
        background: var(--card-bg);
        border-radius: 28px;
        padding: clamp(28px, 5vw, 36px);
        box-shadow: var(--shadow);
        display: flex;
        flex-direction: column;
        gap: 18px;
        border: 1px solid var(--border);
        backdrop-filter: blur(24px);
        -webkit-backdrop-filter: blur(24px);
        position: relative;
        overflow: hidden;
      }

      .card::after {
        content: "";
        position: absolute;
        inset: 12px 18px;
        border-radius: 24px;
        border: 1px solid rgba(255, 255, 255, 0.07);
        pointer-events: none;
      }

      .card > * {
        position: relative;
        z-index: 1;
      }

      label {
        font-weight: 600;
        font-size: 0.95rem;
      }

      textarea {
        width: 100%;
        min-height: 190px;
        padding: 18px;
        border-radius: 20px;
        border: 1px solid rgba(145, 150, 179, 0.35);
        background: linear-gradient(145deg, rgba(255, 255, 255, 0.92), rgba(248, 245, 255, 0.9));
        font-size: 1rem;
        line-height: 1.5;
        resize: vertical;
        color: var(--text);
        transition: border-color 200ms ease, box-shadow 200ms ease, background 200ms ease;
      }

      textarea:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 2px rgba(179, 164, 255, 0.35);
        background: #ffffff;
      }

      textarea.over-limit {
        border-color: var(--danger);
        box-shadow: 0 0 0 3px rgba(212, 88, 116, 0.16);
      }

      .counts {
        display: flex;
        flex-wrap: wrap;
        gap: 12px 24px;
        font-size: 0.95rem;
        color: var(--muted);
        padding: 12px 18px;
        background: rgba(246, 245, 255, 0.7);
        border-radius: 18px;
        border: 1px solid rgba(214, 210, 238, 0.9);
      }

      .insight-stack {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .readability {
        padding: 16px 20px;
        border-radius: 20px;
        border: 1px solid rgba(214, 210, 238, 0.9);
        background: rgba(255, 255, 255, 0.85);
        box-shadow: inset 0 1px 2px rgba(255, 255, 255, 0.4);
      }

      .readability-score {
        margin: 0;
        font-size: 1.35rem;
        font-weight: 700;
        color: var(--text);
      }

      .readability-score span {
        color: var(--accent-strong);
      }

      .readability-label {
        margin: 4px 0;
        font-weight: 600;
        color: var(--accent-strong);
      }

      .readability .muted {
        margin: 0;
      }

      .counts span {
        font-weight: 600;
        color: var(--text);
      }

      .muted {
        color: var(--muted);
      }

      .limit-status {
        font-size: 1rem;
        font-weight: 600;
        color: var(--accent-strong);
        transition: color 200ms ease;
      }

      .limit-status.over-limit {
        color: var(--danger);
      }

      .actions {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 16px;
        flex-wrap: wrap;
      }

      .actions label {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      button {
        border: none;
        border-radius: 999px;
        padding: 14px 24px;
        font-size: 0.95rem;
        font-weight: 600;
        cursor: pointer;
        background: linear-gradient(135deg, #fff6ff, #f1f4ff 50%, #e4edff 80%);
        color: #2e3349;
        transition: transform 150ms ease, background-position 400ms ease, box-shadow 150ms ease;
        border: 1px solid rgba(149, 153, 181, 0.45);
        box-shadow: 0 12px 24px rgba(33, 36, 61, 0.15);
        background-size: 200% 200%;
      }

      button:hover {
        transform: translateY(-2px);
        background-position: 80% 20%;
        box-shadow: 0 18px 32px rgba(33, 36, 61, 0.22);
      }

      input[type="number"] {
        background: rgba(255, 255, 255, 0.9);
        color: var(--text);
        border: 1px solid rgba(149, 153, 181, 0.45);
        border-radius: 999px;
        padding: 8px 14px;
        width: 120px;
        font-size: 0.95rem;
        transition: border-color 200ms ease, box-shadow 200ms ease;
      }

      input[type="number"]:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 2px rgba(179, 164, 255, 0.3);
      }

      textarea:focus-visible,
      input[type="number"]:focus-visible,
      button:focus-visible {
        outline: 3px solid rgba(142, 124, 247, 0.6);
        outline-offset: 3px;
      }

      @media (prefers-reduced-motion: reduce) {
        *,
        *::before,
        *::after {
          transition: none !important;
          animation: none !important;
        }
      }

      @keyframes float {
        from {
          transform: translateY(0px) scale(1);
        }
        to {
          transform: translateY(20px) scale(1.05);
        }
      }

      @media (max-width: 480px) {
        .counts,
        .actions {
          flex-direction: column;
          align-items: flex-start;
        }

        button {
          width: 100%;
          text-align: center;
        }
        .actions {
          gap: 12px;
        }
      }
    </style>
  </head>
  <body>
    <main id="root" aria-live="polite"></main>

    <script type="module">
      import React, { useState, useMemo, useEffect } from "https://esm.sh/react@18.2.0";
      import { createRoot } from "https://esm.sh/react-dom@18.2.0/client";

      const DEFAULT_MAX_LIMIT = 280;
      const STORAGE_KEY = "charCounter:text";
      const LIMIT_KEY = "charCounter:limit";
      const HELPER_TEXT_ID = "counterHelper";

      const countSentences = (text) => {
        const matches = text.match(/[.!?]+/g);
        return Math.max(1, matches ? matches.length : 0);
      };

      const countSyllables = (word) => {
        const cleaned = word.toLowerCase().replace(/[^a-z]/g, "");
        if (!cleaned) return 0;
        if (cleaned.length <= 3) return 1;
        const trimmed = cleaned.replace(/(?:[^laeiouy]es|ed|[^laeiouy]e)$/, "").replace(/^y/, "");
        const matches = trimmed.match(/[aeiouy]{1,2}/g);
        return matches ? matches.length : 1;
      };

      const describeReadability = (score) => {
        if (score >= 90) {
          return { label: "Very easy", summary: "Kid-friendly; most 8-9 year olds can follow along." };
        }
        if (score >= 70) {
          return { label: "Easy", summary: "Great for middle school readers (ages 10-12)." };
        }
        if (score >= 60) {
          return { label: "Fairly easy", summary: "Comfortable for teens and casual adult reading." };
        }
        if (score >= 50) {
          return { label: "Average", summary: "Best suited to adult readers with high-school level." };
        }
        if (score >= 30) {
          return { label: "Challenging", summary: "College-level vocabulary; may lose younger readers." };
        }
        return { label: "Expert", summary: "Professional/academic tone; requires advanced comprehension." };
      };

      const usePersistentText = (key, initialValue = "") => {
        const [text, setText] = useState(() => {
          try {
            return localStorage.getItem(key) ?? initialValue;
          } catch (error) {
            console.warn("Unable to read saved text", error);
            return initialValue;
          }
        });

        useEffect(() => {
          try {
            if (text) {
              localStorage.setItem(key, text);
            } else {
              localStorage.removeItem(key);
            }
          } catch (error) {
            console.warn("Unable to persist text", error);
          }
        }, [key, text]);

        return [text, setText];
      };

      const usePersistentNumber = (key, initialValue) => {
        const [value, setValue] = useState(() => {
          try {
            const stored = localStorage.getItem(key);
            return stored !== null ? Number(stored) || initialValue : initialValue;
          } catch {
            return initialValue;
          }
        });

        useEffect(() => {
          try {
            localStorage.setItem(key, String(value));
          } catch (error) {
            console.warn("Unable to persist number", error);
          }
        }, [key, value]);

        return [value, setValue];
      };

      const CharacterCounter = () => {
        const [text, setText] = usePersistentText(STORAGE_KEY);
        const [limit, setLimit] = usePersistentNumber(LIMIT_KEY, DEFAULT_MAX_LIMIT);

        // Derived metrics stay memoized for consistent values.
        const metrics = useMemo(() => {
          const characters = text.length;
          const words = text.trim() ? text.trim().split(/\s+/).length : 0;
          const remaining = limit - characters;
          return { characters, words, remaining };
        }, [text, limit]);

        const readability = useMemo(() => {
          const trimmed = text.trim();
          if (!trimmed) return null;
          const wordList = trimmed.split(/\s+/);
          if (!wordList.length) return null;
          const sentences = countSentences(trimmed);
          const syllables = wordList.reduce((total, word) => total + countSyllables(word), 0);
          if (!syllables) return null;
          const safeSyllables = Math.max(1, syllables);
          const readingEase =
            206.835 - 1.015 * (wordList.length / sentences) - 84.6 * (safeSyllables / wordList.length);
          const rounded = Math.round(readingEase * 10) / 10;
          const descriptor = describeReadability(rounded);
          return {
            score: rounded,
            ...descriptor,
          };
        }, [text]);

        const overLimit = metrics.remaining < 0;

        const handleChange = (event) => {
          setText(event.target.value);
        };

        const handleClear = () => {
          setText("");
        };

        const handleLimitChange = (event) => {
          const nextValue = Number(event.target.value);
          if (!Number.isNaN(nextValue) && nextValue > 0) {
            setLimit(nextValue);
          }
        };

        return React.createElement(
          "section",
          { className: "card" },
          React.createElement("h1", null, "Character Counter"),
          React.createElement(
            "label",
            { htmlFor: "textInput" },
            "Type or paste your text"
          ),
          React.createElement("textarea", {
            id: "textInput",
            spellCheck: "false",
            value: text,
            onChange: handleChange,
            className: overLimit ? "over-limit" : "",
            "aria-describedby": "limitStatus wordCount charCount",
          }),
          React.createElement(
            "div",
            { className: "insight-stack" },
            React.createElement(
              "div",
              { className: "counts", role: "group", "aria-label": "Live counts" },
              React.createElement(
                "div",
                { id: "charCount" },
                "Characters: ",
                React.createElement("span", null, metrics.characters)
              ),
              React.createElement(
                "div",
                { id: "wordCount" },
                "Words: ",
                React.createElement("span", null, metrics.words)
              ),
              React.createElement(
                "div",
                {
                  className: `limit-status ${overLimit ? "over-limit" : ""}`,
                  id: "limitStatus",
                  role: "status",
                  "aria-live": "polite",
                },
                overLimit
                  ? `Over limit by ${Math.abs(metrics.remaining)}`
                  : `Remaining: ${metrics.remaining}`
              )
            ),
            React.createElement(
              "div",
              { className: "readability", role: "group", "aria-live": "polite", "aria-label": "Readability insights" },
              readability
                ? [
                    React.createElement(
                      "p",
                      { className: "readability-score", key: "score" },
                      "Reading ease: ",
                      React.createElement("span", null, readability.score)
                    ),
                    React.createElement(
                      "p",
                      { className: "readability-label", key: "label" },
                      readability.label
                    ),
                    React.createElement(
                      "p",
                      { className: "muted", key: "summary" },
                      readability.summary
                    ),
                  ]
                : React.createElement(
                    "p",
                    { className: "muted", style: { margin: 0 } },
                    "Start typing to see readability suggestions."
                  )
            )
          ),
          React.createElement(
            "div",
            { className: "actions" },
            React.createElement(
              "label",
              { htmlFor: "limitInput", className: "muted" },
              "Character limit:",
              React.createElement("input", {
                id: "limitInput",
                type: "number",
                min: 1,
                max: 10000,
                value: limit,
                onChange: handleLimitChange,
                "aria-label": "Maximum characters allowed",
                "aria-describedby": HELPER_TEXT_ID,
              })
            ),
            React.createElement(
              "small",
              { className: "muted", id: HELPER_TEXT_ID },
              "Counts update as you type. Clear to reset."
            ),
            React.createElement(
              "button",
              { type: "button", onClick: handleClear, "aria-label": "Clear text input" },
              "Clear Text"
            )
          )
        );
      };

      const root = createRoot(document.getElementById("root"));
      root.render(React.createElement(CharacterCounter));
    </script>
  </body>
</html>
